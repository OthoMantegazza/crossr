---
title: "A quick introduction to crossr"
author: "Otho Mantegazza"
date: "`r Sys.Date()`"
output:
  knitr:::html_vignette:
    toc: yes
    number_sections: true
vignette: >
  %\VignetteIndexEntry{overview of crossr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE, message=FALSE}
library(crossr)
```

# Intro

Crossr is a set of function and a workflow that I use for quantitative comparison of gene expression in different species.

The package builds on the output of [Salmon](https://combine-lab.github.io/salmon/) for transcript quantification and of [Orthofinder](https://github.com/davidemms/OrthoFinder) for matching homologues.

This vignette uses the [GSE69077](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE69077) dataset,  which was published by [Rawat et al. in 2015](https://www.ncbi.nlm.nih.gov/pubmed/26382944) in order to explain the crossr workflow.

This authors of this dataset provide matched RNA-seq timepoints for heat shock and recovery of *Arabidopsis thaliana* and *Arabidopsis lyrata* samples, which are useful for illustrating the crossr workflow.

In order to make this vignette lighter, the workflow is run on a random subset of 500 orthogroups. The sample dataset is available in the exdata folder.



# Read Mapping

Mapping of RNA-seq reads is not directly a part of the crossr workflow.

Crossr requires two normalized expression matrix (one for each species taken into consideration) as starting point. We suggest to use expression values that are not dependent on the length of the gene such as transcript per million (TPM)

For mapping of RNA-seq read we suggest Salmon and we provide the `make_TPM_df()` function that parses and loads the Salmon output directly into R.

These are the **bash** commands that we use RNA-seq quantification with Salmon:


```{bash, eval = FALSE}
## make index
./Salmon-0.7.2_linux_x86_64/bin/salmon\
  index -t path/to/genome.fasta\
  -i th_transcripts_index\
  --type quasi -k 31


## Quantify
for f in reads/*.fastq; do 

base=${f%.fastq}
echo $base
base=${base#reads/}
echo $base

./Salmon-0.7.2_linux_x86_64/bin/salmon quant \
  -i path/to/index -l U \
  -r $f -o $base\
  -p 8
done
```


# Load Output from Salmon
 
The fucntion `make_TPM_df()` loads the Salmon output in R. It takes as input the **path** to the folder that contains **all the Salmon output subfolders** for a species

In detail, the function `make_TPM_df()` extracts the TPM from all the `quant.sf` files in every subfolder and organizes them in a `data.frame`, using the subfolder names as column ids.

This code gets the path to the Salmon output folder and builds the expression matrix for ***A. thaliana***.

```{r}
thaliana_path <- system.file("exdata/thaliana", package = "crossr")
list.files(thaliana_path, recursive = T)
```

```{r}
thaliana <- make_TPM_df(thaliana_path)
str(thaliana)
```

And the same for ***A. lyrata***

```{r}
lyrata_path <- system.file("exdata/lyrata", package = "crossr")
lyrata <- make_TPM_df(lyrata_path)
str(lyrata)
```

## Load sample metadata

In the expression matrices every column represents an RNAseq sample.

Usually **sample metadata** are available they might be used to change the `colnames` of the expression sets from the sample ID to names that provide more immediate information. In this example we can use this [sample sheet](https://www.ncbi.nlm.nih.gov/Traces/study/?acc=SRP058527&go=go) to do so.

This code:

- loads the feature table into R,

```{r}
sample_info_path <- system.file("exdata",
                                "SRP058527_metadata.txt",
                                package = "crossr")

sample_info <-  read.table(sample_info_path,
                           header = TRUE,
                           sep = "\t")  

```

- simplify the sample info so that they can be used as column name,

```{r}
reduce_info <- function(info) {
    if(info == "heat stress 0 h") "0h"
    else if(info == "heat stress 6 h 37\302\260C") "heat_6h"
    else "recovery"
}
sample_info$etime <- vapply(sample_info$exposure_time_s,
                            reduce_info,
                            character(1))
sample_info$etime <- paste(sample_info$etime,
                           c(1, 2),
                           sep = "_")
```

- and set the sample info as column name of both datasets instead of the SRR id.

```{r}
switch_name <- function(name) {
    if(name %in% sample_info$Run_s) {
    sample_info[sample_info$Run_s == name, "etime", drop = TRUE]
    } else name
    }
colnames(thaliana) <- vapply(colnames(thaliana), switch_name, character(1))
colnames(thaliana) <- paste("thal",
                            colnames(thaliana),
                            sep = "_")
str(thaliana)

colnames(lyrata) <- vapply(colnames(lyrata), switch_name, character(1))
colnames(lyrata) <- paste("lyr",
                          colnames(lyrata),
                          sep = "_")
str(lyrata)
```


# Homology groups

The homology groups are called orthogroups in [Orthofinder](https://github.com/davidemms/OrthoFinder) and are defined as:

> The set of genes that are descended from a single gene in the last common ancestor of all the species being considered.

## Ortholog inference

We use **Orthofinder** for ortholog inference. Discussing Orthofinder is beyond the scope of this document; please, refer to its [documentation](https://github.com/davidemms/OrthoFinder/blob/master/OrthoFinder-manual.pdf) for details.

Orthofinder requires the proteomes of the species under study in order to infer orthogroups. In this example we downloaded the proteomes sequences from [NCBI ftp site](ftp://ftp.ncbi.nlm.nih.gov/) using the following version:

- **GCF_000001735.3_TAIR10** for *A. thaliana* - [Download (11.3 Mb)](ftp://ftp.ncbi.nlm.nih.gov/genomes/refseq/plant/Arabidopsis_thaliana/latest_assembly_versions/GCF_000001735.3_TAIR10/GCF_000001735.3_TAIR10_protein.faa.gz),
- **GCF_000004255.1_v.1.0** for *A. lyrata* - [Download (7.0 Mb)](ftp://ftp.ncbi.nlm.nih.gov/genomes/refseq/plant/Arabidopsis_lyrata/all_assembly_versions/GCF_000004255.1_v.1.0/GCF_000004255.1_v.1.0_protein.faa.gz)

The samples are in the `exdata` folder.

We use this **bash** lines in order to produce orthogroups:

```{bash, eval = FALSE}
## blast everything
python OrthoFinder-master/orthofinder.py -f path/to/proteomes -t 3

## make orthogroups
python OrthoFinder-master/orthofinder.py -b path/to/results/WorkingDirectory
```

## Load orthogroups

The orthogroups are provided in the `OrthologousGroups.csv` file in Orthofinder's output.
Orthofinder provides both an `OrthologousGroups.csv` file and `OrthologousGroups.txt` file. 

The function `parse_orthogroups()` takes as input the path to the `OrthologousGroups.csv` file that you want to parse and load in R. Please note that `parse_orthogroups()` is designed for parsing **exclusively the *.csv* file** and not the *.txt* one.

```{r}
ogroups_path <- system.file("exdata",
                            "ogroups_sample.csv",
                            package = "crossr")
ogroups <- parse_orthogroups(ogroups_path)
```

The number of genes for orthogroup can be explored with the function `explore_ogroups()`.

```{r, fig.width= 7, fig.height=4, fig.cap="Genes per orthogroup in the sample dataset."}
explore_ogroups(ogroups)
```


# Convert protein ID in transcript ID

Since orthogroups are inferred on protein sequences but short reads are mapped on transcript sequences you might have to convert the **protein ID** in the orthogroups into **transcript ID**. 

The function `switch_ids()` performs this task. It requires an external file that maps the protein ID to transcript ID, which must be loaded in R.

In this case the **feature tables** containing the mapping were downladed from **NCBI** from the same folder as the proteomes. Again, the samples are in the `exdata` folder.

Loading the feature table from refseq can be challenging, and the issues encountered are often table specific. I ou experiences one of the main sources of issues can be special characters in gene names and gene annotation within the table, such as hashes ( \# ) and quotes ( ' ). The quotes can be find pretty often because they are used in the 5' and 3' notation.

This code loads the *A. thaliana* feature table.
```{r}
thaliana_id_path <- system.file("exdata",
                                "thaliana_features_sample.txt",
                                package = "crossr")
    

thaliana_ids <- read.table(file = thaliana_id_path,
                           sep = "\t", header = FALSE,
                           stringsAsFactors = FALSE,
                           quote = "")

## Not sure why the header is commented with "#"
colnames(thaliana_ids) <-  scan(file = thaliana_id_path,
                                what = "",
                                nlines = 1)[-1]  
```

And this loads the *A. lyrata* one.
```{r}
lyrata_id_path <- system.file("exdata",
                              "lyrata_features_sample.txt",
                              package = "crossr")
    
lyrata_ids <- read.table(file = lyrata_id_path,
                         sep = "\t", header = FALSE,
                         stringsAsFactors = FALSE,
                         quote = "",
                         skip = 1,
                         comment.char = "") # One gene name contains "#"

## Not sure why the header is commented with "#"
colnames(lyrata_ids) <-  scan(file = lyrata_id_path,
                                what = "",
                                nlines = 1)[-1]  
```

Then we can use `switch_ids()` to convert the IDS from *A. thaliana* first, 

```{r}
ogroups <- switch_ids(ogroups = ogroups,
                      ids_table = thaliana_ids,
                      px_id = "product_accession",
                      tx_id = "related_accession",
                      mc.cores = 1)
```

and then the ones from *A. lyrata*.

```{r}
ogroups <- switch_ids(ogroups = ogroups,
                      ids_table = lyrata_ids,
                      px_id = "product_accession",
                      tx_id = "related_accession",
                      mc.cores = 1)
```

Note that the orthogroups contain IDS from **both species**, therefore `switch_ids()` must be called twice.

# Implement a S4 element

Now that we have loaded the expression data and the orthogroup data, we can start implementing an S4 element to organize and link together the expression sets, annotoations and statistics that we have loaded and/or that we are going to produce.

We suggest [this chapter](http://adv-r.had.co.nz/S4.html) from Hadley Wickham's ***Advanced R*** book for an introduction to S4 classes in R.

## The ogset class

The *crossr* package defines the S4 class `ogset` which can be created with the `make_ogset` constructor function.

```{r}
og_set <-  make_ogset(og = ogroups,
                       spec1_exp = thaliana,
                       spec2_exp = lyrata)
```

The `ogset` class is made to store orthogroup expression data and metadata; it has slots for orthogroup expression data, list of genes in orthogroups, single species expression data, design and annotation data. None of these elements is necessary when initialising the object with `make_ogset()` and also an empty set can be initialized. The `ogset` class is modeled on Bioconductor Summarized experiment class.

When the `ogset` element is initialized, the function `check_ogset()` is called in order to check if the elements of the object match with each others. In details, `check_ogset()` checks that:

- the names of the orthogroups (`og`) match the rownames of the orthogroup expression set `og_eset` (if any is given),
- the row names of `colData` (if any) match the column names of the orthogroup expression set `og_eset`,
- the row names of `rowData` (if any) match the row names of the orthogroup expression set `og_eset`,
- the variable in `design` (if any) are colnames of `colData`,
- the rownames of `spec1_colData` match the colnames `spec1_exp` (if any),
- the rownames of `spec2_colData` match the colnames `spec2_exp` (if any),
- `exp_cond` is a character string,
- `exp_cond` is contained in columns of `spec1_colData` and `spec2_colData` and that those columns match.

After adding new elements to an `ogset` object, one can check that the object is still valid by calling `check_ogset()` which returns TRUE if the object is valid.

```{r}
check_ogset(og_set)
```

## Save sample information (colData) in the ogset element

We specify the sample information in the `spec1_colData` and `spec2_colData` slots of the `ogset` element.

In this case we have already expressed the sample information in the colnames of the two datasets, and we can use that to specify very basic colData, but more complex and detailed sample information can be provided.

```{r}
colnames(og_set@spec1_exp)
colnames(og_set@spec2_exp)

coldata_spec1 <- sapply(colnames(og_set@spec1_exp), function(i) strsplit(i, split = "_")[[1]][2])
coldata_spec1 <- data.frame(treat = coldata_spec1, stringsAsFactors = FALSE)
coldata_spec1

coldata_spec2 <- sapply(colnames(og_set@spec2_exp), function(i) strsplit(i, split = "_")[[1]][2])
coldata_spec2 <- data.frame(treat = coldata_spec2, stringsAsFactors = FALSE)
coldata_spec2

og_set@spec1_colData <- coldata_spec1
og_set@spec2_colData <- coldata_spec2
``` 

then we have to provide information on which column of the `coldata_spec` datasets contains the main information for the experimental condition that is used to compare the two species. The levels of this column must be the same for both datasets; which means that we are testing for the response to the same experimental condition in the two species.

```{r}
og_set@exp_cond <- "treat"
```

and we can check that the ogset element is still valid

```{r}
check_ogset(og_set)
```


# Collapse orthologues

As seen in Figure 1 most of the orthogroup contain only two genes, generally one from lyrata and one thaliana. Many other orthogroups though contain different (any) number of genes from one species and from the other. A "quick and dirty"" solution to restore a one to one relationship among features is to collapse the orthologues by adding up the expression values of genes within the same orthogroup.

The basic **assumption** of this method is that **genes in the same orthogroup have the same function**.

The function `collapse_orthologs()`performs this task on the `ogset` class elements, and returns the same element with the collapsed orthogroup expression set in the designated slot.

```{r}
og_set <- collapse_orthologs(og_set, mc.cores = 1)
```

Not all orthogroups contain genes from both species, the orthogroups that contain genes and hence expression data from both species are stored in the slot `og_exp` for further analysis,

```{r}
str(og_set@og_exp)
```

the ones that does not are stored in the slot `og_nomatch`

```{r}
str(og_set@og_nomatch)
```

After we have modified the ogset element (anytime), we can check again for its consistency with the function `check_ogset()` (optional).

```{r}
check_ogset(og_set)
```


# Select genes that behave differently between species

Now that we moved to ortholog-wise expression, we are dealing with a one to one relationship among species.

In order to stay on the safe side I do not perform direct comparison of expression level between the two species, but use the F-value on the interaction term to screen for orthogroups that display a relative different expression pattern between the two species.

Also, since the data have gone through many transformation it is hard to make assumption on their distribution, therefore I do not extract a p-value, rather I use the F-value on the interaction term as a ranking feature, in order to select the genes that seem to behave differently among the species.

The function that fits the linear model and performs ANOVA is called `add_fit()`

----------

First we have to add the column data (the information on the sample) to the ogset element and to provide it with details on the experimental design.

The column data were previoulsy encoded in the colnames of the two expression sets from the two different species. Those names are preserved in the colnames of the ortholog expression set.

```{r}
colnames(og_set@og_exp)
```

So I organize those info in a dataframe:

```{r}
coldata <- data.frame(spc = sapply(colnames(og_set@og_exp),
                                   function(i) strsplit(i, split = "_")[[1]][1]),
                      treat = sapply(colnames(og_set@og_exp),
                                     function(i) strsplit(i, split = "_")[[1]][2]),
                      stringsAsFactors = FALSE)

coldata
```

And provide those information to the ogset element

```{r}
og_set@colData <- coldata
check_ogset(og_set)
```

The experimental design must also be provided, indicating which variable to compare:

```{r}
og_set@design <- ~ 0 + spc + treat + spc:treat
check_ogset(og_set)
```

----------

Now we can calculate the F-values. 

I would suggest to do so on log scaled value, since this should be more appropriate for studying relative changes. This could be done by passing the argument `log_scale = TRUE` to the `add_fit()` function (actually 1 is added to the data before natural log trasformation, so the transformation performed is `log(data + 1)`.

```{r}
og_set <- add_fit(ogset = og_set, log_scale = TRUE)
```

The info on the `log_scale` parameter are stored in the `metadata` slot

# Explore results

We have an F-value associated to any of the three terms in the design formula that we have supplied

```{r}
head(og_set@stats)
```

The F statistic for adding the interaction term to the linear model (in this case `spc:treat`) can be used as a feature that ranks orthogroups in base of how likely they are to behave differently between different species. The ID of the orthogroups with the highest F-value can be extracted with the function `get_top_tags()`.

```{r}
tt <- get_top_tags(og_set, "spc:treat", 10)
tt
```

`get_top_tags()` returns a named numeric vector containing both the id of the top orthogroups and their associated statistics.

## Explore orthogroup expression

The function `plot_all_stages` can be used to plot a stripchart of the expression level of one orthogroups in all the samples.
It requires as input:

- the name of the orthogroup,
- the the ogset element,
- the species encoding in the design formula (in this case `spc`)
- the condition encoding in the design formula (in this case `treat`)

```{r, fig.height=4, fig.width=5}
top_group <- names(get_top_tags(og_set, "spc:treat", 1))
plot_all_stages(orthogroup = top_group,
                ogset = og_set,
                species = "spc",
                condition = "treat",
                ylab = "Log Scaled TPM")
```

This can be combined with faceting in order to plot the expression of multiple orthogroups. For example here I plot the top 12 differentially expressed orthogroups in a 4X3 faceting

```{r, fig.height=9, fig.width=7}
tt <- names(get_top_tags(og_set, "spc:treat", 12))
par(mfrow = c(4, 3))
sapply(tt,
       plot_all_stages,
       ogset = og_set,
       species = "spc",
       condition = "treat",
       ylab = "Log Scaled TPM")
```

## Plot all the genes in one orthogroup

The workflw of `crossr` relies on the assumption that:

> all the genes in one orthogroup have the same function. 

Therefore their exoression values can be added without this resulting in a misenterpretation of the activity of certain groups.

This is a useful working assumption but it is not always verified, therefore I suggest, also, before drawing any conclusion, to explore also the expression pattern of the single genes contained in 1 orthogroup.

This can be achieved with the function `plot_og_genes`.

```{r}
plot_og_genes(ogroup = top_group,
              ogset = og_set,
              ylab = "TPM")
```

As we can see the orthogroup `r top_group` contains only 2 genes, but we can expect orthogroups of different size and different ratios between genes from ine species and from the other.

# Example, orthogroup OG0002779

```{r}
example_group <- "OG0002779"
# also OG0000214 makes a good example
```


Orthogroup `r example_group` contains contains 4 genes, 2 from each species.

The F-value associated to this group is `r og_set@stats[example_group, "spc:treat"]`, and it ranks `r which(names(get_top_tags(og_set, "spc:treat", Inf)) == example_group)` out of 500 groups.

Looks like it is behaving differently in response to heat in the 2 species;

```{r, fig.height=4, fig.width=5}
plot_all_stages(orthogroup = example_group,
                ogset = og_set,
                species = "spc",
                condition = "treat",
                ylab = "Log Scaled TPM")
```

and it contains 4 genes of which one is behaving peculiarly differently than the others.

```{r, fig.height=6, fig.width=6}
par(mfrow = c(2, 2))
plot_og_genes(ogroup = example_group,
              ogset = og_set,
              ylab = "TPM")
```


# Clusters

Ranking orthogroups by F-value of the interaction term and arbitrary cutoffs can be useful to detect genes that behave differently in the two species, but in this way we select genes that behave differently in any way.

Clusters and heatmap can be useful in order to group together orthogroups that behave differently in a similar way and to make sense of it all.



# Session info

Here is the output of `devtools::session_info()` on the system on which this document was compiled:

```{r, echo=FALSE}
devtools::session_info()
```

