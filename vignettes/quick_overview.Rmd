---
title: "A quick introduction to crossr"
author: "Otho Mantegazza"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{overview of crossr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE, message=FALSE}
devtools::load_all()
```

Crossr is a set of function and a workflow that I use for quantitative comparison of gene expression in different species.

The package builds up on the output of [Salmon](https://combine-lab.github.io/salmon/) for transcript quantification and of [Orthofinder](https://github.com/davidemms/OrthoFinder) for matching homologues.

The data in the examples come from here: [GSE69077](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE69077)

## Load Data
 
The fucntion `make_TPM_df()` loads the Salmon output in R. It takes as input the path to the folder that contains all the Salmon output subfolders for a species

```{r}
list.files("../genomes/thaliana")
```

```{r}
list.files("../genomes/thaliana/SRR2033948")
```

The function `make_TPM_df` extracts the TPM from all the `.sf` files in every subfolder and organizes them in a `data.frame`.

Here I use it to produce an expression matrix for the two species `thaliana` and `lyrata`.

```{r}
thaliana <- make_TPM_df("../genomes/thaliana")
str(thaliana)
dim(thaliana)
```

```{r}
lyrata <- make_TPM_df("../genomes/lyrata")
str(lyrata)
dim(lyrata)
```

if more info on the samples are available, it might be useful to change the `colnames` of the expression sets to a more informative version. In this case the feature table is also provided 

```{r}
sample_info <-  read.table("../genomes/SRP058527_metadata.txt",
                           header = TRUE,
                           sep = "\t")  
reduce_info <- function(info) {
    if(info == "heat stress 0 h") "0h"
    else if(info == "heat stress 6 h 37\302\260C") "heat_6h"
    else "recovery"
}
sample_info$etime <- vapply(sample_info$exposure_time_s,
                            reduce_info,
                            character(1))
sample_info$etime <- paste(sample_info$etime,
                           c(1, 2),
                           sep = "_")

switch_name <- function(name) {
    if(name %in% sample_info$Run_s) {
    sample_info[sample_info$Run_s == name, "etime", drop = TRUE]
    } else name
    }
colnames(thaliana) <- vapply(colnames(thaliana), switch_name, character(1))
colnames(thaliana) <- paste("thal",
                            colnames(thaliana),
                            sep = "_")

colnames(lyrata) <- vapply(colnames(lyrata), switch_name, character(1))
colnames(lyrata) <- paste("lyr",
                          colnames(lyrata),
                          sep = "_")
```


## Load orthogroups

The homology groups are called orthogroups and in orthofinder are defined as:

> the set of genes that are descended from a single gene in the last common ancestor of all the species being considered.

The orthogroups are provided in the `OrthologousGroups.csv` file in the orthofinder output.
Orthofinder provides both an `OrthologousGroups.csv` file and `OrthologousGroups.txt` file. The function `parse_orthogroups()` takes as input **exclusively the csv file** provided as a path.

```{r}
ogroups <- parse_orthogroups("../genomes/orthogroups/OrthologousGroups.csv")
```

The dimension of the orthogroups can be explored with the function `explore_ogroups()`

```{r, fig.width= 7, fig.height=4, fig.cap="Figure 1"}
explore_ogroups(ogroups)
```


## Convert protein ID to transcript ID

Since orthogroups are inferred on protein sequences but short reads are mapped on transcript sequences you might have to convert the protein ID in the orthogroups in transcript ID. The function `switch_ids()` performs this task. It requires an external file that maps the protein ID to transcript ID, which must be loaded in R.

Loading the feature table from refseq can be challenging, this loads the *A. thaliana* one
```{r}
thaliana_id_path <- "../genomes/GCF_000001735.3_TAIR10_feature_table.txt"
thaliana_ids <- read.table(file = thaliana_id_path,
                           sep = "\t", header = FALSE,
                           stringsAsFactors = FALSE,
                           quote = "")

## Not sure why the header is commented with "#"
colnames(thaliana_ids) <-  scan(file = thaliana_id_path,
                                what = "",
                                nlines = 1)[-1]  
```

And this loads the *A. lyrata* one.
```{r}
lyrata_id_path <- "../genomes/GCF_000004255.1_v.1.0_feature_table.txt"
lyrata_ids <- read.table(file = lyrata_id_path,
                         sep = "\t", header = FALSE,
                         stringsAsFactors = FALSE,
                         quote = "",
                         skip = 1,
                         comment.char = "") # One gene name contains "#"

## Not sure why the header is commented with "#"
colnames(lyrata_ids) <-  scan(file = lyrata_id_path,
                                what = "",
                                nlines = 1)[-1]  
```


Then we can use `switch_ids()` to convert the IDS from *A. thaliana* first, 

```{r}
ogroups <- switch_ids(ogroups = ogroups,
                      ids_table = thaliana_ids,
                      px_id = "product_accession",
                      tx_id = "related_accession",
                      mc.cores = 4)
```

and then the ones from *A. lyrata*.

```{r}
ogroups <- switch_ids(ogroups = ogroups,
                      ids_table = lyrata_ids,
                      px_id = "product_accession",
                      tx_id = "related_accession",
                      mc.cores = 4)
```

## Collapse orthologues

As seen in Figure 1 most of the orthogroup contain only two genes, generally one from lyrata and one thaliana. Many other orthogroups though contain different (any) number of genes from one species and from the other. A *quick and dirty* solution to restore a one to one relationship among features is to collapse the orthologues by adding up the expression values of genes within the same orthogroup.

The basic **assumption** of this method is that genes in the sam e orthogroup have the same function

The function `collapse_orthogroups()`performs this task.

again, first for *A. thaliana*
```{r}
thaliana_og <- collapse_orthologs(eset = thaliana,
                                  ogroups = ogroups,
                                  mc.cores = 4)
head(thaliana_og)
tail(thaliana_og)
summary(thaliana_og)
```

and then for *A.lyrata*

```{r}
lyrata_og <- collapse_orthologs(eset = lyrata,
                                  ogroups = ogroups,
                                  mc.cores = 4)
head(lyrata_og)
tail(lyrata_og)
summary(lyrata_og)
```

Not all orthogroups contain genes from both species, indeed both orthogroup expression datasets contain `NA` values. We can `merge` the datasets and remove the lines that contain `NA`

```{r}
og_eset <- merge(thaliana_og, lyrata_og,
                 by = "row.names", all = TRUE)
rownames(og_eset) <- og_eset$Row.names; og_eset$Row.names <- NULL
```

While removing `NA`, the orthogroups that are not represented in both species can be saved for later analyses

```{r}
og_NOMATCH <- og_eset[!complete.cases(og_eset), ]
og_eset <- og_eset[complete.cases(og_eset), ]
```


## Select genes that behave differently between species

Now that we moved to ortholog-wise expression, we are dealing with a one to one relationship among species.

In order to stay on the safe side I do not perform direct comparison of expression level between the two species, but use the F-value on the interaction term to screen for orthogroups that display a relative different expression pattern between the two species.

Also, since the data have gone through many transformation it is hard to make assumption on their distribution, therefore I do not extract a p-value, rather I use the F-value on the interaction term as a ranking feature, in order to select the genes that seem to behave differently among the species.

The function that fits the linear model and performs ANOVA is called `add_fit()`

I suggest to run `add_fit()` on log scaled TPMs.

```{r}
og_eset_log <- log(og_eset + 1)
# colnames(og_eset_log)
# 
# colnames(og_eset_log)[1:6] <- paste("thal",
#                                     colnames(og_eset_log)[1:6],
#                                     sep = "_")
# colnames(og_eset_log)[7:12] <- paste("lyr",
#                                     colnames(og_eset_log)[7:12],
#                                     sep = "_")
# colnames(og_eset_log) <- sapply(colnames(og_eset_log), function(i) strsplit(i, split = "\\.")[[1]][1]) 
```

Moreover, the function `add_fit()` requires data on how the columns are grouped together.

```{r}
coldata <- data.frame(spc = sapply(colnames(og_eset_log), function(i) strsplit(i, split = "_")[[1]][1]),
                      treat = sapply(colnames(og_eset_log), function(i) strsplit(i, split = "_")[[1]][2]))

coldata
```

Now we can add the fit

```{r}
og_fit <- add_fit(dat = og_eset_log,
                  coldata = coldata,
                  ogdesign = ~ spc + treat + spc:treat) 
```



